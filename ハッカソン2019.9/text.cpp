//=============================================================================
//
// テキスト読み込み処理 [text.cpp]
// Author : 長山拓実
//
//=============================================================================
#include "text.h"
#include "renderer.h"
#include "manager.h"
#include "input.h"

//=============================================================================
// 静的メンバ変数宣言
//=============================================================================


//=============================================================================
// テキスト読み込みクラスのコンストラクタ
//=============================================================================
CText::CText()
{
}

//=============================================================================
// デストラクタ
//=============================================================================
CText::~CText()
{
}

//=============================================================================
// テキスト読み込みの初期化処理
//=============================================================================
void CText::Init(void)
{
	
}

//=============================================================================
// テキスト読み込みの終了処理
//=============================================================================
void CText::Uninit(void)
{
}

//=============================================================================
// 無効な行を無視する処理
//=============================================================================
char *CText::ReadLine(FILE *pFile, char *pDst)
{
	bool	bChar = true;	// 2文字目の判定に使う

	while (bChar == true)
	{
		// 1行分読み込み
		fgets(pDst, 256, pFile);

		if (pDst[0] == '\n')
		{// 先頭の文字が改行だった場合
		 // 無効な行は無視する(次に進める)
		}
		else if (pDst[0] == '#')
		{// 先頭の文字がコメントだった場合
		 // 無効な行は無視する(次に進める)
		}
		else if (pDst[0] == '\t')
		{
			for (int nCntChar = 0; nCntChar < 256; nCntChar++)
			{
				if (pDst[nCntChar + 1] == '\n')
				{
					// 無効な行
					break;
				}
				else if (pDst[nCntChar + 1] == '#')
				{
					// 無効な行
					break;
				}
				else if (pDst[nCntChar + 1] == '\t')
				{
					// 次の文字へ進める
				}
				else if (pDst[nCntChar + 1] == ' ')
				{
					// 次の文字へ進める
				}
				else
				{
					// 有効な行
					bChar = false;
					break;
				}
			}
		}
		else if (pDst[0] == ' ')
		{
			for (int nCntChar = 0; nCntChar < 256; nCntChar++)
			{
				if (pDst[nCntChar + 1] == '\n')
				{
					// 無効な行
					break;
				}
				else if (pDst[nCntChar + 1] == '#')
				{
					// 無効な行
					break;
				}
				else if (pDst[nCntChar + 1] == '\t')
				{
					// 次の文字へ進める
				}
				else if (pDst[nCntChar + 1] == ' ')
				{
					// 次の文字へ進める
				}
				else
				{
					// 有効な行
					bChar = false;
					break;
				}
			}
		}
		else
		{// 有効な行が見つかれば終了
			bChar = false;
		}
	}

	return pDst;
}

//=============================================================================
// 文字列の先頭を設定
//=============================================================================
char *CText::GetLineTop(char *pSrc)
{
	while (1)
	{
		if (memcmp(pSrc, "\t", strlen("\t")) == 0)
		{// タブだった場合
			pSrc += strlen("\t");
		}
		else if (memcmp(pSrc, " ", strlen(" ")) == 0)
		{// スペースだった場合
			pSrc += strlen(" ");
		}
		else
		{
			break;
		}
	}

	return pSrc;
}

//=============================================================================
// 文字列の先頭を設定
//=============================================================================
int CText::PopString(char *pSrc, char *pDest)
{
	int nWord = 0;
	while (1)
	{
		pSrc++;	// pSrcをスペースかタブが来るまで進める
		nWord++;
		if (memcmp(pSrc, " ", strlen(" ")) == 0)
		{
			pSrc = "\0";
			nWord++;
			break;
		}
		else if (memcmp(pSrc, "\t", strlen("\t")) == 0)
		{
			pSrc = "\0";
			nWord++;
			break;
		}
	}
	strcpy(pDest, pSrc);

	return nWord;
}